# Complete Fibonacci Test Suite
# This tests all aspects of Fibonacci implementation in Nagari

from "console" import { log, error, time, timeEnd }

# Basic recursive Fibonacci (classic implementation)
def fibonacci_recursive(n: int) -> int:
    """Classic recursive Fibonacci - exponential time complexity"""
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# Optimized iterative Fibonacci
def fibonacci_iterative(n: int) -> int:
    """Iterative Fibonacci - linear time complexity"""
    if n <= 1:
        return n

    a, b = 0, 1
    for i in range(2, n + 1):
        a, b = b, a + b
    return b

# Memoized Fibonacci (using dictionary for caching)
memo_cache = {}

def fibonacci_memoized(n: int) -> int:
    """Memoized recursive Fibonacci - improved performance"""
    if n in memo_cache:
        return memo_cache[n]

    if n <= 1:
        result = n
    else:
        result = fibonacci_memoized(n - 1) + fibonacci_memoized(n - 2)

    memo_cache[n] = result
    return result

# Generator-based Fibonacci sequence
def fibonacci_generator(limit: int):
    """Generator that yields Fibonacci numbers up to limit"""
    a, b = 0, 1
    count = 0
    while count < limit:
        yield a
        a, b = b, a + b
        count += 1

# Matrix-based Fibonacci (advanced mathematical approach)
def matrix_multiply(A: list, B: list) -> list:
    """Multiply two 2x2 matrices"""
    return [
        [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]],
        [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]]
    ]

def matrix_power(matrix: list, n: int) -> list:
    """Raise matrix to power n using fast exponentiation"""
    if n == 1:
        return matrix

    if n % 2 == 0:
        half_power = matrix_power(matrix, n // 2)
        return matrix_multiply(half_power, half_power)
    else:
        return matrix_multiply(matrix, matrix_power(matrix, n - 1))

def fibonacci_matrix(n: int) -> int:
    """Matrix-based Fibonacci - logarithmic time complexity"""
    if n <= 1:
        return n

    base_matrix = [[1, 1], [1, 0]]
    result_matrix = matrix_power(base_matrix, n)
    return result_matrix[0][1]

# Async Fibonacci (demonstrates async capabilities)
async def fibonacci_async(n: int) -> int:
    """Async version of iterative Fibonacci"""
    if n <= 1:
        return n

    a, b = 0, 1
    for i in range(2, n + 1):
        # Simulate some async work
        await new Promise(resolve => setTimeout(resolve, 1))
        a, b = b, a + b
    return b

# Test helper functions
def test_fibonacci_implementation(func, name: str, test_cases: list) -> dict:
    """Test a Fibonacci implementation with given test cases"""
    log(f"\nüß™ Testing {name}")
    log("=" * 50)

    results = {
        "name": name,
        "passed": 0,
        "failed": 0,
        "errors": [],
        "performance": {}
    }

    for test_case in test_cases:
        n, expected = test_case["input"], test_case["expected"]

        try:
            time(f"{name}_n{n}")
            actual = func(n)
            timeEnd(f"{name}_n{n}")

            if actual == expected:
                log(f"‚úì fibonacci({n}) = {actual}")
                results["passed"] += 1
            else:
                log(f"‚úó fibonacci({n}) = {actual}, expected {expected}")
                results["failed"] += 1
                results["errors"].append({
                    "input": n,
                    "expected": expected,
                    "actual": actual
                })
        except Exception as e:
            log(f"‚úó fibonacci({n}) raised exception: {e}")
            results["failed"] += 1
            results["errors"].append({
                "input": n,
                "expected": expected,
                "error": str(e)
            })

    success_rate = (results["passed"] / (results["passed"] + results["failed"])) * 100
    log(f"\nüìä Results: {results['passed']}/{results['passed'] + results['failed']} passed ({success_rate:.1f}%)")

    return results

# Comprehensive test cases
test_cases = [
    {"input": 0, "expected": 0},
    {"input": 1, "expected": 1},
    {"input": 2, "expected": 1},
    {"input": 3, "expected": 2},
    {"input": 4, "expected": 3},
    {"input": 5, "expected": 5},
    {"input": 6, "expected": 8},
    {"input": 7, "expected": 13},
    {"input": 8, "expected": 21},
    {"input": 9, "expected": 34},
    {"input": 10, "expected": 55},
    {"input": 15, "expected": 610},
    {"input": 20, "expected": 6765}
]

# Performance test cases (for comparing different implementations)
performance_test_cases = [
    {"input": 0, "expected": 0},
    {"input": 1, "expected": 1},
    {"input": 10, "expected": 55},
    {"input": 20, "expected": 6765},
    {"input": 30, "expected": 832040}
]

def test_fibonacci_sequence_generator():
    """Test the generator-based Fibonacci sequence"""
    log("\nüß™ Testing Fibonacci Generator")
    log("=" * 50)

    expected_sequence = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
    actual_sequence = list(fibonacci_generator(10))

    if actual_sequence == expected_sequence:
        log(f"‚úì Generator produces correct sequence: {actual_sequence}")
        return True
    else:
        log(f"‚úó Generator failed. Expected: {expected_sequence}, Got: {actual_sequence}")
        return False

async def test_async_fibonacci():
    """Test the async Fibonacci implementation"""
    log("\nüß™ Testing Async Fibonacci")
    log("=" * 50)

    test_cases_async = [
        {"input": 5, "expected": 5},
        {"input": 10, "expected": 55}
    ]

    for test_case in test_cases_async:
        n, expected = test_case["input"], test_case["expected"]
        try:
            result = await fibonacci_async(n)
            if result == expected:
                log(f"‚úì async fibonacci({n}) = {result}")
            else:
                log(f"‚úó async fibonacci({n}) = {result}, expected {expected}")
        except Exception as e:
            log(f"‚úó async fibonacci({n}) raised exception: {e}")

def performance_comparison():
    """Compare performance of different Fibonacci implementations"""
    log("\n‚ö° Performance Comparison")
    log("=" * 50)

    implementations = [
        ("Iterative", fibonacci_iterative),
        ("Memoized", fibonacci_memoized),
        ("Matrix", fibonacci_matrix)
    ]

    test_values = [20, 25, 30]

    for n in test_values:
        log(f"\nComputing Fibonacci({n}):")

        for name, func in implementations:
            try:
                time(f"{name}_perf")
                result = func(n)
                timeEnd(f"{name}_perf")
                log(f"  {name}: {result}")
            except Exception as e:
                log(f"  {name}: Error - {e}")

def edge_cases_test():
    """Test edge cases and error handling"""
    log("\nüîç Testing Edge Cases")
    log("=" * 50)

    edge_cases = [
        {"input": -1, "description": "Negative input"},
        {"input": -5, "description": "Large negative input"},
        {"input": 0, "description": "Zero input"},
        {"input": 1, "description": "One input"}
    ]

    for case in edge_cases:
        n, desc = case["input"], case["description"]
        log(f"\nTesting {desc} (n={n}):")

        try:
            result = fibonacci_iterative(n)
            log(f"  Result: {result}")
        except Exception as e:
            log(f"  Exception: {e}")

def comprehensive_validation():
    """Validate that all implementations produce the same results"""
    log("\nüîÑ Cross-Implementation Validation")
    log("=" * 50)

    validation_cases = [0, 1, 2, 5, 10, 15]
    implementations = [
        ("Recursive", fibonacci_recursive),
        ("Iterative", fibonacci_iterative),
        ("Memoized", fibonacci_memoized),
        ("Matrix", fibonacci_matrix)
    ]

    all_consistent = True

    for n in validation_cases:
        results = {}
        log(f"\nValidating Fibonacci({n}):")

        for name, func in implementations:
            try:
                if name == "Recursive" and n > 15:
                    # Skip recursive for large numbers due to performance
                    results[name] = "SKIPPED (performance)"
                    continue

                result = func(n)
                results[name] = result
                log(f"  {name}: {result}")
            except Exception as e:
                results[name] = f"ERROR: {e}"
                log(f"  {name}: ERROR - {e}")

        # Check consistency (excluding errors and skipped)
        valid_results = [v for v in results.values() if isinstance(v, int)]
        if len(valid_results) > 1 and len(set(valid_results)) > 1:
            log(f"  ‚ö†Ô∏è  INCONSISTENT RESULTS for n={n}")
            all_consistent = False
        elif valid_results:
            log(f"  ‚úì All implementations consistent")

    return all_consistent

# Main test runner
async def run_complete_fibonacci_tests():
    """Run the complete Fibonacci test suite"""
    log("üöÄ Complete Fibonacci Test Suite")
    log("=" * 60)
    log(f"Testing multiple Fibonacci implementations with comprehensive test cases")

    # Test basic implementations
    implementations = [
        ("Iterative", fibonacci_iterative),
        ("Memoized", fibonacci_memoized),
        ("Matrix", fibonacci_matrix)
    ]

    all_results = []

    for name, func in implementations:
        result = test_fibonacci_implementation(func, name, test_cases)
        all_results.append(result)

    # Test recursive with limited cases (to avoid exponential slowdown)
    limited_cases = test_cases[:10]  # Only test up to fibonacci(10)
    recursive_result = test_fibonacci_implementation(
        fibonacci_recursive, "Recursive", limited_cases
    )
    all_results.append(recursive_result)

    # Test generator
    generator_success = test_fibonacci_sequence_generator()

    # Test async implementation
    await test_async_fibonacci()

    # Test edge cases
    edge_cases_test()

    # Performance comparison
    performance_comparison()

    # Cross-validation
    validation_success = comprehensive_validation()

    # Final summary
    log("\n" + "=" * 60)
    log("üìã FINAL SUMMARY")
    log("=" * 60)

    total_passed = sum(r["passed"] for r in all_results)
    total_tests = sum(r["passed"] + r["failed"] for r in all_results)
    overall_success_rate = (total_passed / total_tests) * 100 if total_tests > 0 else 0

    log(f"Total tests run: {total_tests}")
    log(f"Total passed: {total_passed}")
    log(f"Overall success rate: {overall_success_rate:.1f}%")
    log(f"Generator test: {'‚úì PASSED' if generator_success else '‚úó FAILED'}")
    log(f"Cross-validation: {'‚úì PASSED' if validation_success else '‚úó FAILED'}")

    if overall_success_rate >= 95 and generator_success and validation_success:
        log("\nüéâ ALL FIBONACCI TESTS COMPLETED SUCCESSFULLY!")
    else:
        log("\n‚ö†Ô∏è  Some tests failed. Please review the results above.")

    return {
        "overall_success_rate": overall_success_rate,
        "total_tests": total_tests,
        "total_passed": total_passed,
        "generator_success": generator_success,
        "validation_success": validation_success,
        "detailed_results": all_results
    }

# Run the tests if this file is executed directly
if __name__ == "__main__":
    log("Starting Fibonacci test execution...")
    try:
        result = await run_complete_fibonacci_tests()
        log(f"\n‚ú® Test execution completed with {result['overall_success_rate']:.1f}% success rate")
    except Exception as e:
        error(f"Failed to run tests: {e}")
